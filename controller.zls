(* Controller *)

open Parameters

let step = 0.01

let solve_inputs ((tx,ty,tz),thrust) = (i1,i2,i3,i4) where
	rec a1 = tx /. (l *. k)
	and a2 = ty /. (l *. k)
	and a3 = tz /. b
	and a4 = thrust /. k
	and imax = omega_max_rotor *. omega_max_rotor
	and i1 = max 0.0 (min imax (-0.5 *. a1 +. 0.25 *. (a3 +. a4)))
	and i2 = max 0.0 (min imax (0.5 *. a2 +. 0.25 *. (a4 -. a3)))
	and i3 = max 0.0 (min imax (0.5 *. a1 +. 0.25 *. (a3 +. a4)))
	and i4 = max 0.0 (min imax (-0.5 *. a2 +. 0.25 *. (a4 -. a3)))

let node euler_integrator (x0,xdot) = x where
	rec x = x0 -> pre (x +. xdot *. step)

let pid_kd = 10.
let pid_kp = 10.
let pid_ki = 10.
let node pid_controller xdot = output where
	rec x = euler_integrator (0.0,xdot)
	and xi = euler_integrator (0.0,x)
	and output = pid_kd *. xdot +. pid_kp *. x +. pid_ki *. xi

let node controller ((accel_x,accel_y,accel_z),(gyro_x,gyro_y,gyro_z)) = (i1,i2,i3,i4) where
	rec control_x = pid_controller gyro_x
	and control_y = pid_controller gyro_y
	and control_z = pid_controller gyro_z
	and (tx,ty,tz) = (-. ix *. control_x, -. iy *. control_y, -. iz *. control_z)
	and (i1,i2,i3,i4) = solve_inputs((tx,ty,tz),  m *. g)

