(* Controller *)

open Parameters

let step = 0.01

let solve_inputs ((tx,ty,tz),thrust) = (i1,i2,i3,i4) where
	rec a1 = tx /. (l *. k)
	and a2 = ty /. (l *. k)
	and a3 = tz /. b
	and a4 = thrust /. k
	and imax = omega_max_rotor *. omega_max_rotor
	and i1 = max 0.0 (min imax (-0.5 *. a1 +. 0.25 *. (a3 +. a4)))
	and i2 = max 0.0 (min imax (0.5 *. a2 +. 0.25 *. (a4 -. a3)))
	and i3 = max 0.0 (min imax (0.5 *. a1 +. 0.25 *. (a3 +. a4)))
	and i4 = max 0.0 (min imax (-0.5 *. a2 +. 0.25 *. (a4 -. a3)))

let node euler_integrator (x0,xdot) = x where
	rec x = x0 -> pre (x +. xdot *. step)

let pid_kd = 10.
let pid_kp = 20.
let pid_ki = 40.
let node pid_controller xdot = output where
	rec x = euler_integrator (0.0,xdot)
	and xi = euler_integrator (0.0,x)
	and output = pid_kd *. xdot +. pid_kp *. x +. pid_ki *. xi

let node filterFIR5 (x,(b0,b1,b2,b3,b4)) = y where 
	rec a0 = x 
	and a1 = x fby a0
	and a2 = x fby a1
	and a3 = x fby a2
	and a4 = x fby a3
	and y = b0 *. a0 +. b1 *. a1 +. b2 *. a2 +. b3 *. a3 +. b4 *. a4

let node movingAverage5 x = filterFIR5(x,(0.2,0.2,0.2,0.2,0.2))

let node controller ((accel_x,accel_y,accel_z),(gyro_x,gyro_y,gyro_z)) = (i1,i2,i3,i4) where
	rec control_x = pid_controller (filterFIR5 (gyro_x, (0.2,0.2,0.2,0.2,0.2)))
	and control_y = pid_controller (filterFIR5 (gyro_y, (0.2,0.2,0.2,0.2,0.2)))
	and control_z = pid_controller (filterFIR5 (gyro_z, (0.2,0.2,0.2,0.2,0.2)))
	and (tx,ty,tz) = (-. ix *. control_x, -. iy *. control_y, -. iz *. control_z)
	and (i1,i2,i3,i4) = solve_inputs((tx,ty,tz),  m *. g)

let node sensor (value,sigma) = value +. (Tools.random_normal ()) *. sigma

let hybrid simulate_controller ((ax,ay,az),(wx,wy,wz)) = (i1,i2,i3,i4) where
	rec init i1 = 0.0
	and init i2 = 0.0
	and init i3 = 0.0
	and init i4 = 0.0
	and present (period (step)) ->

		let accel_error = 0.25 *. g and gyro_error = 0.25 *. pi /. 180. in
	
		(* add a Gaussian noise to simulate the sensors *)
		let accel_x = sensor (last ax, accel_error)
		and accel_y = sensor (last ay, accel_error)
		and accel_z = sensor (last az, accel_error)
		and gyro_x = sensor (wx, gyro_error)
		and gyro_y = sensor (wy, gyro_error)
		and gyro_z = sensor (wz, gyro_error) in

		let (j1,j2,j3,j4) = controller ((accel_x,accel_y,accel_z),(gyro_x,gyro_y,gyro_z)) in

		(* smooth the output to prevent brutal speed variation *)
		do  
			i1 = movingAverage5 j1 and 
			i2 = movingAverage5 j2 and 
			i3 = movingAverage5 j3 and 
			i4 = movingAverage5 j4 
		done

