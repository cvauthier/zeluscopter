(* Controller *)

open Parameters

let step = 0.01

let solve_inputs ((tx,ty,tz),thrust) = (i1,i2,i3,i4) where
	rec a1 = tx /. (l *. k)
	and a2 = ty /. (l *. k)
	and a3 = tz /. b
	and a4 = thrust /. k
	and imax = omega_max_rotor *. omega_max_rotor
	and i1 = max 0.0 (min imax (-0.5 *. a1 +. 0.25 *. (a3 +. a4)))
	and i2 = max 0.0 (min imax (0.5 *. a2 +. 0.25 *. (a4 -. a3)))
	and i3 = max 0.0 (min imax (0.5 *. a1 +. 0.25 *. (a3 +. a4)))
	and i4 = max 0.0 (min imax (-0.5 *. a2 +. 0.25 *. (a4 -. a3)))

let node euler_integrator (x0,xdot) = x where
	rec x = x0 -> pre (x +. xdot *. step)

let node pid_controller (xdot,kp,kd,ki) = output where
	rec x = euler_integrator (0.0,xdot)
	and xi = euler_integrator (0.0,x)
	and output = kd *. xdot +. kp *. x +. ki *. xi

let node filterFIR5 (x,(b0,b1,b2,b3,b4)) = y where 
	rec a0 = x 
	and a1 = x fby a0
	and a2 = x fby a1
	and a3 = x fby a2
	and a4 = x fby a3
	and y = b0 *. a0 +. b1 *. a1 +. b2 *. a2 +. b3 *. a3 +. b4 *. a4

let node movingAverage5 x = filterFIR5(x,(0.2,0.2,0.2,0.2,0.2))

let node imu ((accel_x,accel_y,accel_z),(gyro_x,gyro_y,gyro_z)) = ((x,y,z),(vx,vy,vz),(phi,theta,psi),(phidot,thetadot,psidot)) where
	rec vx = euler_integrator (0.0,accel_x)
	and vy = euler_integrator (0.0,accel_y)
	and vz = euler_integrator (0.0,accel_z)
	and x = euler_integrator (0.0,vx)
	and y = euler_integrator (0.0,vy)
	and z = euler_integrator (Parameters.init_z,vz)
	and (phidot,thetadot,psidot) = Physics.omega_to_thetadot((gyro_x,gyro_y,gyro_z),(phi,theta,psi))
	and phi = euler_integrator (0.0,phidot)
	and theta = euler_integrator (0.0,thetadot)
	and psi = euler_integrator (0.0,psidot)

let node controller ((accel_x,accel_y,accel_z),(gyro_x,gyro_y,gyro_z)) = (i1,i2,i3,i4) where
	
	rec faccel_x = filterFIR5 (accel_x, (0.8,0.1,0.1,0.0,0.0))
	and faccel_y = filterFIR5 (accel_y, (0.8,0.1,0.1,0.0,0.0))
	and faccel_z = filterFIR5 (accel_z, (0.8,0.1,0.1,0.0,0.0))
	and fgyro_x = filterFIR5 (gyro_x, (0.8,0.1,0.1,0.0,0.0))
	and fgyro_y = filterFIR5 (gyro_y, (0.8,0.1,0.1,0.0,0.0))
	and fgyro_z = filterFIR5 (gyro_z, (0.8,0.1,0.1,0.0,0.0))

	and ((x,y,z),(vx,vy,vz),(phi,theta,psi),(phidot,thetadot,psidot)) = imu ((faccel_x,faccel_y,faccel_z),(fgyro_x,fgyro_y,fgyro_z))
	
	and control_x = pid_controller (phidot,40.,20.,10.0) +. x *. 0.0
	and control_y = pid_controller (thetadot,40.,20.,10.0) +. y *. 0.0
	and control_z = pid_controller (psidot,40.,20.,10.0) +. z *. 0.0
	
	and (tx,ty,tz) = (-. ix *. control_x, -. iy *. control_y, -. iz *. control_z)
	and (i1,i2,i3,i4) = solve_inputs((tx,ty,tz),  m *. g /. ((cos phi) *. (cos theta)))

let node sensor (value,sigma) = value +. (World.random_normal ()) *. sigma

let hybrid simulate_controller ((ax,ay,az),(wx,wy,wz)) = (i1,i2,i3,i4) where
	rec init i1 = 0.0
	and init i2 = 0.0
	and init i3 = 0.0
	and init i4 = 0.0
	and present (period (step)) ->

		let accel_error = 0.1 *. g and gyro_error = 0.1 *. pi /. 180. in
	
		(* add a Gaussian noise to simulate the sensors *)
		let accel_x = sensor (0.0 -> last ax, accel_error)
		and accel_y = sensor (0.0 -> last ay, accel_error)
		and accel_z = sensor (0.0 -> last az, accel_error)
		and gyro_x = sensor (0.0 -> last wx, gyro_error)
		and gyro_y = sensor (0.0 -> last wy, gyro_error)
		and gyro_z = sensor (0.0 -> last wz, gyro_error) in

		let (j1,j2,j3,j4) = controller ((accel_x,accel_y,accel_z),(gyro_x,gyro_y,gyro_z)) in

		(* smooth the output to prevent brutal speed variation *)
		do  
			i1 = movingAverage5 j1 and 
			i2 = movingAverage5 j2 and 
			i3 = movingAverage5 j3 and 
			i4 = movingAverage5 j4 
		done

