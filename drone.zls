open Matrix

(* Parameters *)

let L = 0.05 (* length of an arm (m) *)
let m = 0.063 (* mass (kg) *)
let g = 9.81 (* gravity (m.s^-2) *)
let (Ix,Iy,Iz) = (2e-4,2e-4,2e-4) (* moments of inertia *)

let omega_max_rotor = 5000. *. 3.1415 /. 180.0 (* max rotor speed (rad.s^-1) *)

(* Other parameters *)
let kd = 1e-5
let k = 5e-5
let b = 1

let R (phi,theta,psi) = (R11,R12,R13,R21,R22,R23,R31,R32,R33) where
	R11 = (cos theta) *. (cos psi) and
	R12 = (sin phi) *. (sin theta) *. (cos psi) -. (cos phi) *. (sin psi) and
	R13 = (cos phi) *. (sin theta) *. (cos psi) +. (sin phi) *. (sin psi) and
	R21 = (cos theta) *. (sin psi) and
	R22 = (sin phi) *. (sin theta) *. (sin psi) +. (cos phi) *. (cos psi) and
	R23 = (cos phi) *. (sin theta) *. (sin psi) -. (sin phi) *. (cos psi) and
	R31 = -1.0 *. (sin theta) and
	R32 = (sin phi) *. (cos theta) and
	R33 = (cos phi) *. (cos theta)

let thetadot_to_omega(thetadot,(phi,theta,psi)) = omega where
	rec s_th = sin theta and c_th = cos theta
	and s_ph = sin phi and c_ph = cos phi
	and T = (1., 0., -1. *. s_th, 0., c_ph, c_th *. s_ph, 0., -1. *. s_ph, c_th *. c_ph)
	and omega = mat33xvec3(T,thetadot)

let omega_to_thetadot(omega,(phi,theta,psi)) = thetadot where
	rec s_ph = sin phi and c_ph = cos phi
	and c_th = cos theta and t_th = tan theta
	and T = (1.,s_ph *. t_th,c_ph *. t_th,0.,c_ph,-1. *. s_ph,0.,s_ph /. c_th,c_ph /. c_th)
	and thetadot = mat33xvec3(T,omega)

let acceleration ((inp1,inp2,inp3,inp4),v,theta) = acc where
	rec gravity = (0,0,g)
	and	friction = scalarxvec3 (-1. *. kd, v)
	and thrust = mat33xvec3 ((R theta),(0,0, -1. *. k *. (inp1 +. inp2 +. inp3 +. inp4)))
	and acc = addvec3(gravity, (scalarxvec3(1. /. m,(addvec3(friction,thrust)))))

let angular_acceleration ((inp1,inp2,inp3,inp4),omega) = omegadot where
	rec torques = (L *. k *. (inp1 -. inp3) ,L *. k *. (inp2 -. inp4), b *. (inp1 -. inp2 +. inp3 -. inp4))
	and (wx,wy,wz) = omega
	and (foo1,foo2,foo3) = subvec3 (torques, (cross33(omega,(Ix *. xw, Iy *. wy, Iz *. wz))))
	and omegadot = (foo1 /. Ix, foo2 /. Iy, foo3 /. Iz)

let controller () = scalarxvec3(omega_rotor_max,(1.,1.,1.))

let hybrid drone (thetadot0) =
	((x,y,z),(vx,vy,vz),(phi,theta,psi),(phidot,thetadot,psidot)) where
	rec der x = vx init 0.0
	and der y = vy init 0.0
	and der z = vz init -10.0
	and der vx = ax init 0.0
	and der vy = ay init 0.0
	and der vz = az init 0.0
	and inputs = controller ()
	and (ax,ay,az) = acceleration (inputs,(vx,vy,vz),(phi,theta,psi))
	and (aax,aay,aaz) = angular_acceleration (inputs,(wx,wy,wz))
	and (wx0,wy0,wz0) = thetadot_to_omega(thetadot0,(phi,theta,psi))
	and der wx = aax init wx0
	and der wy = aay init wy0
	and der wz = aaz init wz0
	and (phidot,thetadot,psidot) = omega_to_thetadot((wx,wy,wz),(phi,theta,psi))
	and der phi = phidot init 0.0
	and der theta = thetadot init 0.0
	and der psi = psidot init 0.0

(* ** plotting ** *)

open Scope

let node plot (t,((x,y,z),(vx,vy,vz),(phi,theta,psi),(phidot,thetadot,psidot))) =
  let s1 = scope (0.0, 20.0, ("z", linear, -1. *. z)) in
  let s2 = scope (0.0, 20.0, ("vz", linear, -1. *. z)) in
  window2 ("drone", 10.0, t, s1, s2)

(* ** main ** *)

let hybrid main () = 
  let der t = 1.0 init 0.0 in
  let data = drone () in
  present (period (0.10)) -> plot (t,data); ()

