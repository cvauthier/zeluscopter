open Matrix

(* Parameters *)

let dr_l = 0.0624 (* length of an arm (m) *)
let m = 0.063 (* mass (kg) *)
let g = 9.81 (* gravity (m.s^-2) *)
let ix = 5.82e-4
let iy = 7.17e-4
let iz = 1e-4 (* moments of inertia *)

let omega_max_rotor = 5000. *. 3.1416 /. 180.0 (* max rotor speed (rad.s^-1) *)

(* Other parameters *)
let kd = 1e-5
let k = 1.60e-4
let b = 3.87e-6

let pi = 3.1416

(* physics functions *)

let body_to_inertial (phi,theta,psi) = (r11,r12,r13,r21,r22,r23,r31,r32,r33) where
	r11 = (cos theta) *. (cos psi) and
	r12 = (sin phi) *. (sin theta) *. (cos psi) -. (cos phi) *. (sin psi) and
	r13 = (cos phi) *. (sin theta) *. (cos psi) +. (sin phi) *. (sin psi) and
	r21 = (cos theta) *. (sin psi) and
	r22 = (sin phi) *. (sin theta) *. (sin psi) +. (cos phi) *. (cos psi) and
	r23 = (cos phi) *. (sin theta) *. (sin psi) -. (sin phi) *. (cos psi) and
	r31 = -1.0 *. (sin theta) and
	r32 = (sin phi) *. (cos theta) and
	r33 = (cos phi) *. (cos theta)

let thetadot_to_omega(thetadot,(phi,theta,psi)) = omega where
	rec s_th = sin theta and c_th = cos theta
	and s_ph = sin phi and c_ph = cos phi
	and mat = (1., 0., -1. *. s_th, 0., c_ph, c_th *. s_ph, 0., -1. *. s_ph, c_th *. c_ph)
	and omega = mat33xvec3(mat,thetadot)

let omega_to_thetadot(omega,(phi,theta,psi)) = thetadot where
	rec s_ph = sin phi and c_ph = cos phi
	and c_th = cos theta and t_th = tan theta
	and mat = (1.,s_ph *. t_th,c_ph *. t_th,0.,c_ph,-1. *. s_ph,0.,s_ph /. c_th,c_ph /. c_th)
	and thetadot = mat33xvec3(mat,omega)

let acceleration ((inp1,inp2,inp3,inp4),v,theta) = acc where
	rec gravity = (0.,0.,g)
	and	friction = scalarxvec3 (-. kd, v)
	and thrust = mat33xvec3 ((body_to_inertial theta),(0.,0., -1. *. k *. (inp1 +. inp2 +. inp3 +. inp4)))
	and acc = addvec3(gravity, (scalarxvec3(1. /. m,(addvec3(friction,thrust)))))

let angular_acceleration ((inp1,inp2,inp3,inp4),omega) = omegadot where
	rec torques = (dr_l *. k *. (inp3 -. inp1), dr_l *. k *. (inp2 -. inp4), b *. (inp1 -. inp2 +. inp3 -. inp4))
	and (wx,wy,wz) = omega
	and (foo1,foo2,foo3) = subvec3 (torques, (crossvec3(omega,(ix *. wx, iy *. wy, iz *. wz))))
	and omegadot = (foo1 /. ix, foo2 /. iy, foo3 /. iz)

(* controller *)

let solve_inputs (wanted_torque,wanted_thrust) = (i1,i2,i3,i4) where
	rec (tx,ty,tz) = wanted_torque
	and a1 = tx /. (dr_l *. k)
	and a2 = ty /. (dr_l *. k)
	and a3 = tz /. b
	and a4 = wanted_thrust /. k
	and imax = omega_max_rotor *. omega_max_rotor
	and i1 = max 0.0 (min imax (-0.5 *. a1 +. 0.25 *. (a3 +. a4)))
	and i2 = max 0.0 (min imax (0.5 *. a2 +. 0.25 *. (a4 -. a3)))
	and i3 = max 0.0 (min imax (0.5 *. a1 +. 0.25 *. (a3 +. a4)))
	and i4 = max 0.0 (min imax (-0.5 *. a2 +. 0.25 *. (a4 -. a3)))

let dt = 0.01
let node euler_integrator (x0,xdot) = x where
	rec x = x0 -> pre (x +. xdot *. dt)

let pd_k1 = 10.
let pd_k2 = 10.
let node pd_error angledot = error where
	rec angle = euler_integrator (0.0,angledot)
	and error = pd_k1 *. angledot +. pd_k2 *. angle

let node controller (phidot,thetadot,psidot) = inputs where
	rec ephi 	 = pd_error phidot
	and etheta = pd_error thetadot
	and epsi   = pd_error psidot
	and wanted_torque = (-. ix *. ephi, -. iy *. etheta, -. iz *. epsi)
	and inputs = solve_inputs (wanted_torque, m *. g)

(* simulation *)

let hybrid get_inputs (phidot,thetadot,psidot) = (i1,i2,i3,i4) where
	rec init i1 = 0.0
	and init i2 = 0.0
	and init i3 = 0.0
	and init i4 = 0.0
	and present (period (dt)) -> do (i1,i2,i3,i4) = controller (phidot,thetadot,psidot) done

let hybrid drone (thetadot0) =
	((x,y,z),(vx,vy,vz),(ax,ay,az),(phi,theta,psi),(phidot,thetadot,psidot)) where
	rec der x = vx init 0.0
	and der y = vy init 0.0
	and der z = vz init -10.0
	and der vx = ax init 0.0
	and der vy = ay init 0.0
	and der vz = az init 0.0
	and inputs = get_inputs (phidot,thetadot,psidot)
	and (ax,ay,az) = acceleration (inputs,(vx,vy,vz),(phi,theta,psi))
	and (aax,aay,aaz) = angular_acceleration (inputs,(wx,wy,wz))
	and (wx0,wy0,wz0) = thetadot_to_omega(thetadot0,(phi,theta,psi))
	and der wx = aax init wx0
	and der wy = aay init wy0
	and der wz = aaz init wz0
	and (phidot,thetadot,psidot) = omega_to_thetadot((wx,wy,wz),(phi,theta,psi))
	and der phi = phidot init 0.0 reset | up (last phi -. pi) -> -. pi
																			| up (-. pi -. last phi) -> pi
	and der theta = thetadot init 0.0 
	and der psi = psidot init 0.0 reset | up (last psi -. pi) -> -. pi
																			| up (-. pi -. last psi) -> pi

(* ** plotting ** *)

open Scope

let node plot (t,((x,y,z),(vx,vy,vz),(ax,ay,az),(phi,theta,psi),(phidot,thetadot,psidot))) =
  let s1 = scope (-0.005, 0.005, ("phi", linear, phi)) in
  let s2 = scope (-0.005, 0.005, ("psi", linear, psi)) in
  let s3 = scope (-0.01, 0.01, ("ax", linear, ax)) in
	let s4 = scope (0.0, 20.0, ("z", linear, -. z)) in
  window4 ("drone", 10.0, t, s1, s2, s3, s4)

(* ** main ** *)

let hybrid main () = 
  let der t = 1.0 init 0.0 in
  let data = drone (1.23,1.12,-0.81) in
  present (period (0.10)) -> plot (t,data); ()

